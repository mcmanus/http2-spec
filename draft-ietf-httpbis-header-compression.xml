<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type='text/xsl' href='lib/rfc2629.xslt' ?>

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc linkmailto="no"?>
<?rfc editing="no"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>

<rfc category="std"
    ipr="trust200902"
    docName="draft-ietf-httpbis-header-compression-latest"
    x:maturity-level="proposed"
    xmlns:x="http://purl.org/net/xml2rfc/ext">
    <x:feedback template="mailto:ietf-http-wg@w3.org?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
    <front>
        <title abbrev="HPACK">HPACK - Header Compression for HTTP/2</title>

        <author initials="R." surname="Peon" fullname="Roberto Peon">
            <organization>Google, Inc</organization>
            <address>
                <email>fenix@google.com</email>
            </address>
        </author>

        <author initials="H." surname="Ruellan" fullname="HervÃ© Ruellan">
            <organization>Canon CRF</organization>
            <address>
                <email>herve.ruellan@crf.canon.fr</email>
            </address>
        </author>

        <date year="2014"/>
        <area>Applications</area>
        <workgroup>HTTPbis</workgroup>
        <keyword>HTTP</keyword>
        <keyword>Header</keyword>
        <abstract>
            <t>
                This specification defines HPACK, a compression format for
                efficiently representing HTTP header fields in the context
                of HTTP/2.
            </t>
        </abstract>

      <note title="Editorial Note (To be removed by RFC Editor)">
        <t>
          Discussion of this draft takes place on the HTTPBIS working group
          mailing list (ietf-http-wg@w3.org), which is archived at <eref
          target="http://lists.w3.org/Archives/Public/ietf-http-wg/"/>.
        </t>
        <t>
          Working Group information can be found at
          <eref target="http://tools.ietf.org/wg/httpbis/"/>; that specific to
          HTTP/2 are at <eref target="http://http2.github.io/"/>.
        </t>
        <t>
          The changes in this draft are summarized in <xref
          target="changes.since.draft-ietf-httpbis-header-compression-07"/>.
        </t>
      </note>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                This specification defines HPACK, a compression format for
                efficiently representing HTTP header fields in the context
                of HTTP/2 (see <xref target="HTTP2"/>).
            </t>
        </section>

        <section title="Overview" anchor="overview">
            <t>
                In HTTP/1.1 (see <xref target="RFC7230"/>), header fields are
                encoded without any form of compression.  As web pages have grown
                to include dozens to hundreds of requests, the redundant
                header fields in these requests now measurably increase
                latency and unnecessarily consume bandwidth (see <xref
                target="PERF1"/> and <xref target="PERF2"/>).
            </t>

            <t>
                SPDY <xref target="SPDY"/> initially addressed this
                redundancy by compressing header fields using the DEFLATE
                format <xref target="DEFLATE"/>, which proved
                very effective at efficiently representing the redundant header
                fields.  However, that approach exposed a security risk as
                demonstrated by the CRIME attack (see <xref target="CRIME"/>).
            </t>

            <t>
                This document describes HPACK, a new compressor for header
                fields which eliminates redundant header fields, is not
                vulnerable to known security attacks, and which also has a
                bounded memory requirement for use in constrained environments.
            </t>

            <section title="Outline">
                <t>
                    The HTTP header field encoding defined in this document
                    is based on a header table that maps name-value pairs to
                    index values.  The header table is incrementally updated
                    during the HTTP/2 connection.
                </t>
                <t>
                    A set of header fields is treated as an unordered collection
                    of name-value pairs (possibly containing duplicate pairs).
                    Names and values are considered to be opaque sequences of
                    octets.  The order of header fields is not guaranteed to
                    be preserved after being compressed and decompressed.
                </t>
                <t>
                    As two consecutive sets of header fields often have header
                    fields in common, each set is coded as a difference from
                    the previous set. The goal is to only encode the changes
                    (header fields present in one of the sets that are absent
                    from the other) between the two sets of header fields.
                </t>
                <t>
                    A header field is represented either literally or as a
                    reference to a name-value pair in the header table. A set
                    of header fields is stored as a set of references to
                    entries in the header table (possibly keeping only a
                    subset of it, as some header fields may be missing a
                    corresponding entry in the header table). Differences
                    between consecutive sets of header fields are encoded as
                    changes to the set of references.
                </t>
                <t>
                    The encoder is responsible for deciding which header
                    fields to insert as new entries in the header table.  The
                    decoder executes the modifications to the header table and
                    reference set prescribed by the encoder, reconstructing
                    the set of header fields in the process.  This enables
                    decoders to remain simple and understand a wide variety of
                    encoders.
                </t>
                <t>
                    Examples illustrating the use of these different
                    mechanisms to represent header fields are available in
                    <xref target="examples"/>.
                </t>
            </section>
        </section>

        <section title="Header Field Encoding" anchor="header.encoding">
            <section title="Encoding Concepts" anchor="encoding.concepts">
                <t>
                    The encoding and decoding of header fields relies on some
                    components and concepts:
                    <list style="hanging">
                        <t hangText="Header Field:">
                            A name-value pair.  Both the name and value are
                            treated as opaque sequences of octets.
                        </t>
                        <t hangText="Header Table:">
                            The header table (see <xref
                                target="header.table"/>) is a component used
                            to associate stored header fields to index values.
                        </t>
                        <t hangText="Static Table:">
                            The static table (see <xref
                                target="static.table"/>) is a component used
                            to associate static header fields to index values.
                            This data is ordered, read-only, always
                            accessible, and may be shared amongst all encoding
                            contexts.
                        </t>
                        <t hangText="Reference Set:">
                            The reference set (see <xref
                                target="reference.set"/>) is a component
                            containing an unordered set of references to
                            entries in the header table. It doesn't contain
                            duplicate references. The reference set is used
                            for the differential encoding of a new header set.
                        </t>
                        <t hangText="Header Set:">
                            A header set is an unordered group of
                            header fields that are encoded jointly. It can
                            contain duplicate header fields. A complete set
                            of key-value pairs contained in a HTTP request or
                            response is a header set.
                        </t>
                        <t hangText="Header Field Representation:">
                            A header field can be represented in encoded form
                            either as a literal or as an index (see <xref
                                target="header.representation"/>).
                        </t>
                        <t hangText="Header Block:">
                            The entire set of encoded header field
                            representations which, when decoded, yield a
                            complete header set.
                        </t>
                        <t hangText="Header Field Emission:">
                            When decoding a set of header field
                            representations, some operations emit a header
                            field (see <xref target="header.emission"/>).
                            Emitted header fields are added to the current
                            header set and cannot be removed.
                        </t>
                    </list>
                </t>

                <section title="Encoding Context" anchor="encoding.context">
                    <t>
                        The set of mutable structures used within an encoding
                        context includes a header table and a reference set.
                        Everything else is either immutable or conceptual.
                    </t>
                    <t>
                        HTTP messages are exchanged between a client and a
                        server in both directions.  The encoding of header
                        fields in each direction is independent from the
                        other direction.  There is a single encoding context
                        for each direction used to encode all header fields
                        sent in that direction.
                    </t>
                </section>

                <section title="Header Table" anchor="header.table">
                    <t>
                        A header table consists of a list of header fields
                        maintained in first-in, first-out order.
                        The first and newest entry in a header table is always
                        at index 1, and the oldest entry of a header table is
                        at the index len(header table).
                    </t>
                    <t>
                        The header table is initially empty.
                    </t>
                    <t>
                        There is typically no need for the header table to
                        contain duplicate entries. However, duplicate entries
                        MUST NOT be treated as an error by a decoder.
                    </t>
                    <t>
                        The encoder decides how to update the header table and
                        as such can control how much memory is used by the
                        header table. To limit the memory requirements of
                        the decoder, the header table size is strictly
                        bounded (see <xref target="maximum.table.size"/>).
                    </t>
                    <t>
                        The header table is updated during the processing of
                        a set of header field representations (see <xref
                            target="header.representation.processing"/>).
                    </t>
                </section>

                <section title="Reference Set" anchor="reference.set">
                    <t>
                        A reference set is an unordered set of references to
                        entries of the header table. It never contains
                        duplicate references.
                    </t>
                    <t>
                        The reference set is initially empty.
                    </t>
                    <t>
                        The reference set is updated during the processing of
                        a set of header field representations (see <xref
                            target="header.representation.processing"/>).
                    </t>
                    <t>
                        The reference set enables differential encoding,
                        whereby only differences between the previous header
                        set and the current header set need to be encoded. The
                        use of differential encoding is optional for any
                        header set.
                    </t>
                    <t>
                        When an entry is evicted from the header table, if it
                        was referenced from the reference set, its reference
                        is removed from the reference set.
                    </t>
                    <t>
                        To limit the memory requirements on the decoder side
                        for handling the reference set, only entries within
                        the header table can be contained in the reference
                        set. To still allow entries from the static table to
                        take advantage of the differential encoding, when a
                        header field is represented as a reference to an entry
                        of the static table, this entry is inserted into the
                        header table (see <xref
                            target="header.representation.processing"/>).
                    </t>
                </section>

                <section title="Header Field Representation"
                    anchor="header.representation">
                    <t>
                        An encoded header field can be represented either as a
                        literal or as an index.
                    </t>
                    <t>
                        <list style="hanging">
                            <t hangText="Literal Representation:">
                                A literal representation defines a new header
                                field. The header field name is represented
                                either literally or as a reference to an entry
                                of the header table. The header field value is
                                represented literally.
                            </t>
                            <t>
                                Three different literal representations are
                                provided:
                                <list style="symbols">
                                    <t>
                                        A literal representation that does not
                                        add the header field to the header
                                        table (see <xref
                                            target="literal.header.without.indexing"/>).
                                    </t>
                                    <t>
                                        A literal representation that does not
                                        add the header field to the header
                                        table and require that this header
                                        field always use a literal
                                        representation, in particular when
                                        re-encoded by an intermediary (see
                                        <xref
                                            target="literal.header.never.indexed"/>).
                                    </t>
                                    <t>
                                        A literal representation that adds the
                                        header field as a new entry at the
                                        beginning of the header table (see
                                        <xref
                                            target="literal.header.with.incremental.indexing"/>).
                                    </t>
                                </list>
                            </t>
                            <t hangText="Indexed Representation:">
                                The indexed representation defines a header
                                field as a reference to an entry in either the
                                header table or the static table (see <xref
                                    target="indexed.header.representation"/>).
                            </t>
                            <t>
                                Indices between 1 and len(header table),
                                inclusive, refer to elements in the header
                                table, with index 1 referring to the beginning
                                of the table.
                            </t>
                            <t>
                                Indices between len(header table) + 1 and
                                len(header table) + len(static table),
                                inclusive, refer to elements in the static
                                table, where the index len(header table) + 1
                                refers to the first entry in the static table.
                            </t>
                            <t>
                                Any other indices MUST be treated as a
                                decoding error.
                            </t>
                        </list>
                    </t>
                    <t>
                        <figure title="Index Address Space">
                            <artwork type="drawing"><![CDATA[
       <----------  Index Address Space ---------->
       <-- Header  Table -->  <-- Static  Table -->
       +---+-----------+---+  +---+-----------+---+
       | 1 |    ...    | k |  |k+1|    ...    | n |
       +---+-----------+---+  +---+-----------+---+
       ^                   |
       |                   V
Insertion Point      Dropping Point
]]></artwork>
                        </figure>
                    </t>
                </section>

                <section title="Header Field Emission" anchor="header.emission">
                    <t>
                        The emission of a header field is the process of
                        marking a header field as belonging to the current
                        header set. Once a header has been emitted, it cannot
                        be removed from the current header set.
                    </t>
                    <t>
                        On the decoding side, an emitted header field can be
                        safely passed to the upper processing layer as part of
                        the current header set. The decoder MAY pass the
                        emitted header fields to the upper processing layer in
                        any order.
                    </t>
                    <t>
                        By emitting header fields instead of emitting header
                        sets, the decoder can be implemented in a streaming
                        way, and as such has only to keep in memory the header
                        table and the reference set. This bounds the amount of
                        memory used by the decoder, even in presence of a very
                        large set of header fields. The management of memory
                        for handling very large sets of header fields can
                        therefore be deferred to the upper processing layers.
                    </t>
                </section>
            </section>

            <section title="Header Block Decoding"
                anchor="header.block.decoding">
                <t>
                    The processing of a header block to obtain a header set is
                    defined in this section.  To ensure that the decoding will
                    successfully produce a header set, a decoder MUST obey the
                    following rules.
                </t>

                <section title="Header Field Representation Processing"
                    anchor="header.representation.processing">
                    <t>
                        All the header field representations contained in a
                        header block are processed in the order in which they
                        appear, as specified below.
                    </t>
                    <t>
                        An <spanx>indexed representation</spanx> corresponding
                        to an entry <spanx>present</spanx> in the
                        reference set entails the following actions:
                        <list style="symbols">
                            <t>The entry is removed from the reference
                                set.</t>
                        </list>
                    </t>
                    <t>
                        An <spanx>indexed representation</spanx> corresponding
                        to an entry <spanx>not present</spanx> in the
                        reference set entails the following actions:
                        <list style="symbols">
                            <t>If referencing an element of the static table:
                                <list style="symbols">
                                    <t>The header field corresponding to the
                                        referenced entry is emitted.</t>
                                    <t>The referenced static entry is inserted
                                        at the beginning of the header
                                        table.</t>
                                    <t>A reference to this new header table
                                        entry is added to the reference set,
                                        except if this new entry didn't fit
                                        in the header table.</t>
                                </list>
                            </t>
                            <t>If referencing an element of the header table:
                                <list style="symbols">
                                    <t>The header field corresponding to the
                                        referenced entry is emitted.</t>
                                    <t>The referenced header table entry is
                                        added to the reference set.</t>
                                </list>
                            </t>
                        </list>
                    </t>
                    <t>
                        A <spanx>literal representation</spanx> that is
                        <spanx>not added</spanx> to the header table entails
                        the following action:
                        <list style="symbols">
                            <t>The header field is emitted.</t>
                        </list>
                    </t>
                    <t>
                        A <spanx>literal representation</spanx> that is
                        <spanx>added</spanx> to the header table entails
                        the following actions:
                        <list style="symbols">
                            <t>The header field is emitted.</t>
                            <t>The header field is inserted at the beginning
                                of  the header table.</t>
                            <t>A reference to the new entry is added to the
                                reference set, except if this new entry didn't
                                fit in the header table.</t>
                        </list>
                    </t>
                </section>

                <section title="Reference Set Emission"
                    anchor="reference.set.emission">
                    <t>
                        Once all the representations contained in a header
                        block have been processed, the header fields
                        referenced in the reference set which have not
                        previously been emitted during this processing are
                        emitted.
                    </t>
                </section>

                <section title="Header Set Completion"
                    anchor="header.set.completion">
                    <t>
                        Once all of the header field representations have been
                        processed, and the remaining items in the reference
                        set have been emitted, the header set is complete.
                    </t>
                </section>
            </section>

            <section title="Header Table Management"
                anchor="header.table.management">
                <section title="Maximum Table Size"
                    anchor="maximum.table.size">
                    <t>
                        To limit the memory requirements on the decoder side,
                        the mutable structures used in an encoding context are
                        constrained. These mutable structures are the header
                        table and the reference set.
                    </t>
                    <t>
                        The size of the header table is bounded by a maximum
                        size defined by the decoder.  The size of the header
                        table MUST always be lower than or equal to this
                        maximum size.
                    </t>
                    <t>
                        The reference set can only contain references to
                        entries of the header table, and can't contain
                        references to entries of the static table. In
                        addition, it can't contain duplicate references.
                        Therefore, its maximum size is bounded by the size of
                        the header table.
                    </t>
                    <t>
                        By default, the maximum size of the header table is
                        equal to the value of the HTTP/2 setting
                        SETTINGS_HEADER_TABLE_SIZE defined by the decoder (see
                        <xref target="HTTP2"/>).  The encoder can change this
                        maximum size (see <xref
                            target="encoding.context.update"/>), but it MUST
                        stay lower than or equal to the value of
                        SETTINGS_HEADER_TABLE_SIZE.
                    </t>
                    <t>
                        After applying an updated value of the HTTP/2 setting
                        SETTINGS_HEADER_TABLE_SIZE that changes the maximum
                        size of the header table used by the encoder, the
                        encoder MUST signal this change via an encoding
                        context update (see <xref
                            target="encoding.context.update"/>). This encoding
                        context update MUST occurs at the beginning of the
                        first header block following the SETTINGS frame sent
                        to acknowledge the application of the updated
                        settings.
                    </t>
                    <t>
                        The size of the header table is the sum of the
                        size of its entries.
                    </t>
                    <t>
                        The size of an entry is the sum of its name's length
                        in octets (as defined in <xref
                            target="string.literal.representation" />), of its
                        value's length in octets (<xref
                            target="string.literal.representation" />) and of
                        32 octets.
                    </t>
                    <t>
                        The lengths are measured on the non-encoded entry
                        name and entry value (for the case when a Huffman
                        encoding is used to transmit string values).
                    </t>
                    <t>
                        The 32 octets are an accounting for the entry
                        structure overhead. For example, an entry structure
                        using two 64-bits pointers to reference the name and
                        the value and the entry, and two 64-bits integer for
                        counting the number of references to these name and
                        value would use 32 octets.
                    </t>
                </section>
                <section title="Entry Eviction When Header Table Size Changes"
                    anchor="entry.eviction">
                    <t>
                        Whenever an entry is evicted from the header table,
                        any reference to that entry contained by the reference
                        set is removed.
                    </t>
                    <t>
                        Whenever the maximum size for the header table is made
                        smaller, entries are evicted from the end of the
                        header table until the size of the header table is
                        less than or equal to the maximum size.
                    </t>
                    <t>
                        The eviction of an entry from the header
                        table causes the index of the entries in the static
                        table to be reduced by one.
                    </t>
                </section>
                <section title="Entry Eviction when Adding New Entries"
                    anchor="entry.addition">
                    <t>
                        Whenever a new entry is to be added to the table, any
                        name referenced by the representation of this new
                        entry is cached, and then entries are evicted from the
                        end of the header table until the size of the header
                        table is less than or equal to (maximum size - new
                        entry size), or until the table is empty.
                    </t>
                    <t>
                        If the size of the new entry is less than or equal to
                        the maximum size, that entry is added to the table.  It
                        is not an error to attempt to add an entry
                        that is larger than the maximum size.
                    </t>
                </section>
            </section>
        </section>

        <section title="Detailed Format" anchor="detailed.format">
            <section title="Low-level representations"
                anchor="low-level.representation">
                <section title="Integer representation"
                    anchor="integer.representation">
                    <t>
                        Integers are used to represent name indexes, pair
                        indexes or string lengths. To allow for optimized
                        processing, an integer representation always finishes
                        at the end of an octet.
                    </t>
                    <t>
                        An integer is represented in two parts: a prefix that
                        fills the current octet and an optional list of octets
                        that are used if the integer value does not fit within
                        the prefix.  The number of bits of the prefix (called
                        N) is a parameter of the integer representation.
                    </t>
                    <t>
                        The N-bit prefix allows filling the current octet.  If
                        the value is small enough (strictly less than
                        2<x:sup>N</x:sup>-1), it is encoded within the N-bit
                        prefix.  Otherwise all the bits of the prefix are set
                        to 1 and the value is encoded using an unsigned
                        variable length integer representation (see <eref
                            target="http://en.wikipedia.org/wiki/Variable-length_quantity"/>).
                        N is always between 1 and 8 bits. An integer starting
                        at an octet-boundary will have an 8-bit prefix.
                    </t>
                    <t>
                        The algorithm to represent an integer I is as follows:
                        <figure><artwork type = "inline"><![CDATA[
if I < 2^N - 1, encode I on N bits
else
    encode (2^N - 1) on N bits
    I = I - (2^N - 1)
    while I >= 128
         encode (I % 128 + 128) on 8 bits
         I = I / 128
    encode I on 8 bits
]]></artwork></figure>
                    </t>
                    <t>
                        For informational purpose, the algorithm to decode an
                        integer I is as follows:
                        <figure><artwork type="inline"><![CDATA[
decode I from the next N bits
if I < 2^N - 1, return I
else
    M = 0
    repeat
        B = next octet
        I = I + (B & 127) * 2^M
        M = M + 7
    while B & 128 == 128
    return I
]]></artwork></figure>
                    </t>
                    <t>
                        Examples illustrating the encoding of integers are
                        available in <xref
                            target="integer.representation.examples"/>.
                    </t>
                    <t>
                        This integer representation allows for values of
                        indefinite size.  It is also possible for an encoder to
                        send a large number of zero values, which can waste
                        octets and could be used to overflow integer values.
                        Excessively large integer encodings - in value or octet
                        length - MUST be treated as a decoding error.  Different
                        limits can be set for each of the different uses of
                        integers, based on implementation constraints.
                    </t>
                </section>

                <section title="String Literal Representation"
                    anchor="string.literal.representation">
                    <t>
                        Header field names and header field values can be
                        represented as literal string. A literal string is
                        encoded as a sequence of octets, either by directly
                        encoding the literal string's octets, or by using a
                        canonical <xref target="CANON"/> Huffman encoding
                        <xref target="HUFF"/>.
                    </t>
                    <figure title="String Literal Representation">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| H |    String Length (7+)     |
+---+---------------------------+
|  String Data (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <t>
                        A literal string representation contains the following
                        fields:
                    </t>
                    <t>
                        <list style="hanging">
                            <t hangText="H:">
                                A one bit flag, H, indicating whether or not the
                                octets of the string are Huffman encoded.
                            </t>
                            <t hangText="String Length:">
                                The number of octets used to encode the string
                                literal, encoded as an integer with 7-bit prefix
                                (see <xref target="integer.representation"/>).
                            </t>
                            <t hangText="String Data:">
                                The encoded data of the string literal. If H is
                                '0', then the encoded data is the raw octets of
                                the string literal. If H is '1', then the encoded
                                data is the Huffman encoding of the string
                                literal.
                            </t>
                        </list>
                    </t>
                    <t>
                        String literals which use Huffman encoding are encoded
                        with the Huffman codes defined in <xref
                            target="huffman.codes"/> (see examples inRequest
                        Examples with Huffman <xref
                            target="request.examples.with.huffman"/> and in
                        Response Examples with Huffman <xref
                            target="response.examples.with.huffman"/>). The
                        encoded data is the bitwise concatenation of the
                        Huffman codes corresponding to each octet of the
                        string literal.
                    </t>
                    <t>
                        As the Huffman encoded data doesn't always end at an
                        octet boundary, some padding is inserted after it up
                        to the next octet boundary. To prevent this padding to
                        be misinterpreted as part of the string literal, the
                        most significant bits of the EOS (end-of-string) entry
                        in the Huffman table are used.
                    </t>
                    <t>
                        Upon decoding, an incomplete Huffman code at the end
                        of the encoded data is to be considered as padding and
                        discarded. A padding strictly longer than 7 bits MUST
                        be treated as a decoding error. A padding not
                        corresponding to the most significant bits of the EOS
                        entry MUST be treated as a decoding error. A Huffman
                        encoded string literal containing the EOS entry MUST
                        be treated as a decoding error.
                    </t>
                </section>
            </section>

            <section title="Indexed Header Field Representation"
                anchor="indexed.header.representation">
                <t>
                    An indexed header field representation either identifies an
                    entry in the header table or static table.  The processing
                    of an indexed header field representation is described in
                    <xref target="header.representation.processing"/>.
                </t>

                <figure title="Indexed Header Field">
                    <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
]]></artwork>
                </figure>
                <t>
                    This representation starts with the '1' 1-bit pattern,
                    followed by the index of the matching pair, represented as
                    an integer with a 7-bit prefix.
                </t>
                <t>
                    The index value of 0 is not used. It MUST be treated as a
                    decoding error if found in an indexed header field
                    representation.
                </t>
            </section>

            <section title="Literal Header Field Representation"
                anchor="literal.header.representation">
                <t>
                    Literal header field representations contain a literal
                    header field value.  Header field names are either
                    provided as a literal or by reference to an existing
                    header table or static table entry.
                </t>
                <t>
                    Literal representations all result in the emission of a
                    header field when decoded.
                </t>

                <section title="Literal Header Field with Incremental Indexing"
                    anchor="literal.header.with.incremental.indexing">
                    <t>
                        A literal header field with incremental indexing adds
                        a new entry to the header table.
                    </t>
                    <figure title="Literal Header Field with Incremental Indexing -
                        Indexed Name">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |      Index (6+)       |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <figure title="Literal Header Field with Incremental Indexing -
                        New Name">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |           0           |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <t>
                        This representation starts with the '01' 2-bit
                        pattern.
                    </t>
                    <t>
                        If the header field name matches the header field name
                        of a (name, value) pair stored in the Header Table or
                        Static Table, the header field name can be represented
                        using the index of that entry. In this case, the index
                        of the entry (which is strictly greater than 0)
                        is represented as an integer with a 6-bit prefix (see
                        <xref target="integer.representation"/>).
                    </t>
                    <t>
                        Otherwise, the header field name is represented as a
                        literal. The value 0 is represented on 6 bits followed
                        by the header field name (see <xref
                            target="string.literal.representation" />).
                    </t>
                    <t>
                        The header field name representation is followed by
                        the header field value represented as a literal string
                        as described in <xref
                            target="string.literal.representation" />.
                    </t>
                </section>

                <section title="Literal Header Field without Indexing"
                    anchor="literal.header.without.indexing">
                    <t>
                        A literal header field without indexing causes the
                        emission of a header field without altering the header
                        table.
                    </t>
                    <figure title="Literal Header Field without Indexing - Indexed Name">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |  Index (4+)   |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <figure title="Literal Header Field without Indexing - New Name">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |       0       |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <t>
                        The literal header field without indexing
                        representation starts with the '0000' 4-bit pattern.
                    </t>
                    <t>
                        If the header field name matches the header field name
                        of a (name, value) pair stored in the Header Table or
                        Static Table, the header field name can be represented
                        using the index of that entry. In this case, the index
                        of the entry (which is strictly greater than 0)
                        is represented as an integer with a 4-bit prefix (see
                        <xref target="integer.representation"/>).
                    </t>
                    <t>
                        Otherwise, the header field name is represented as a
                        literal. The value 0 is represented on 4 bits followed
                        by the header field name (see <xref
                            target="string.literal.representation" />).
                    </t>
                    <t>
                        The header field name representation is followed by
                        the header field value represented as a literal string
                        as described in <xref
                            target="string.literal.representation" />.
                    </t>
                </section>

                <section title="Literal Header Field Never Indexed"
                    anchor="literal.header.never.indexed">
                    <t>
                        A literal header field never indexed causes the emission
                        of a header field without altering the header table.
                        Intermediaries MUST use the same representation for
                        encoding this header field.
                    </t>
                    <figure title="Literal Header Field Never Indexed - Indexed Name">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |  Index (4+)   |
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <figure title="Literal Header Field Never Indexed - New Name">
                        <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 1 |       0       |
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
]]></artwork>
                    </figure>
                    <t>
                        The literal header field never indexed
                        representation starts with the '0001' 4-bit pattern.
                    </t>
                    <t>
                        When a header field is represented as a literal header
                        field never indexed, it MUST always be encoded
                        with this same representation. In particular, when a
                        peer sends a header field that it received represented
                        as a literal header field never indexed, it MUST use
                        the same representation to forward this header field.
                    </t>
                    <t>
                        This representation is intended for protecting header
                        field values that are not to be put at risk by
                        compressing them (see <xref
                            target="compression.based.attacks"/> for more
                        details).
                    </t>
                    <t>
                        The encoding of the representation is the same as for
                        the literal header field without indexing
                        representation (see <xref
                            target="literal.header.without.indexing"/>).
                    </t>
                </section>
            </section>

            <section title="Encoding Context Update"
                anchor="encoding.context.update">
                <t>
                    An encoding context update causes the immediate application of a
                    change to the encoding context.
                </t>
                <figure title="Context Update">
                    <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 | F |      ...      |
+---+---------------------------+
]]></artwork>
                </figure>
                <t>
                    An encoding context update starts with the '001' 3-bit
                    pattern.
                </t>
                <t>
                    It is followed by a flag specifying the type of the
                    change, and by any data necessary to describe the change
                    itself.
                </t>
                <figure title="Reference Set Emptying">
                    <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 | 1 |       0       |
+---+---------------------------+
]]></artwork>
                </figure>
                <t>
                    The flag bit being set to '1' signals that the reference
                    set is emptied. The remaining bits are set to '0'.
                </t>
                <figure title="Maximum Header Table Size Change">
                    <artwork type="inline"><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 | 0 | Max size (4+) |
+---+---------------------------+
]]></artwork>
                </figure>
                <t>
                    The flag bit being set to '0' signals that a change to the
                    maximum size of the header table. This new maximum size
                    MUST be lower than or equal to the value of the HTTP/2
                    setting SETTINGS_HEADER_TABLE_SIZE (see <xref
                        target="HTTP2"/>).
                </t>
                <t>
                    The new maximum size is encoded as an integer with a 4-bit
                    prefix (see <xref target="integer.representation"/>).
                </t>
                <t>
                    Change in the maximum size of the header table can trigger
                    entry evictions (see <xref target="entry.eviction"/>).
                </t>
            </section>
        </section>

        <section anchor="Security" title="Security Considerations">

            <t>
                This section describes potential areas of security concern with HPACK:
                <list style="symbols">
                    <t>
                        Use of compression as a length-based oracle for
                        verifying guesses about secrets that are compressed into
                        a shared compression context.
                    </t>
                    <t>
                        Denial of service resulting from exhausting processing
                        or memory capacity at a decompressor.
                    </t>
                </list>
            </t>

            <section title="Probing Header Table State"
                anchor="compression.based.attacks">
                <t>
                    HPACK reduces the length of header field encodings by
                    exploiting the redundancy inherent in protocols like HTTP.
                    The ultimate goal of this is to reduce the amount of data
                    that is required to send HTTP requests or responses.
                </t>
                <t>
                    The header table that HPACK uses can be probed by an
                    attacker that has the following capabilities: to encode and
                    transmit header fields; and to observe the length of those
                    fields as they are encoded.  The allows an attacker to
                    adaptively modify requests in order to confirm guesses about
                    the header table state.  If the HPACK encoder compresses a
                    guess into a shorter length, the attacker can observe the
                    encoded length and infer that the guess was correct.
                </t>
                <t>
                    This is possible because while TLS provides confidentiality
                    protection for content, it only provides a limited amount of
                    protection for the length of that content.
                    <list style="hanging">
                        <t hangText="Note:">
                            Padding schemes only provide limited protection
                            against an attacker with these capabilities,
                            potentially only forcing an increased number of
                            guesses to learn the length associated with a given
                            guess.  Padding schemes also work directly against
                            compression by increasing the number of bits that
                            are transmitted.
                        </t>
                    </list>
                </t>
                <t>
                    Attacks like <xref target="CRIME"/> demonstrated the
                    existence of these general attacker capabilities.  The
                    specific attack exploited the fact that <xref
                    target="DEFLATE"/> removes redundancy based on prefix
                    matching.  This permitted the attacker to confirm guesses a
                    character at a time, reducing an exponential-time attack
                    into a constant time attack.
                </t>

                <section title="Applicability to HPACK and HTTP">
                    <t>
                        HPACK mitigates but does not completely prevent attacks
                        modelled on <xref target="CRIME"/> by forcing a guess to
                        match an entire header field value, rather than
                        individual characters.  An attacker can only learn
                        whether a guess is correct or not, so is reduced to a
                        brute force guess for the header field values.
                    </t>
                    <t>
                        The viability of recovering specific header field values
                        therefore depends on the entropy of values.  As a
                        result, values with high entropy are unlikely to be
                        recovered successfully.  However, values with low
                        entropy remain vulnerable.
                    </t>
                    <t>
                        Attacks of this nature are possible any time that two
                        mutually distrustful entities control requests or
                        responses that are placed onto a single HTTP/2
                        connection.  If the shared HPACK compressor permits one
                        entity to add entries to the header table, and the other
                        to access those entries, then the state of the table can
                        be learned.
                    </t>
                    <t>
                        Having requests or responses from mutually distrustful
                        entities occurs when an intermediary either:
                        <list style="symbols">
                            <t>
                                sends requests from multiple clients on a single
                                connection toward an origin server, or
                            </t>
                            <t>
                                takes responses from multiple origin servers and
                                places them on a shared connection toward a
                                client.
                            </t>
                        </list>
                        Web browsers also need to assume that requests made on
                        the same connection by different <xref
                        target="ORIGIN">web origins</xref> are made by mutually
                        distrustful entities.
                    </t>
                </section>

                <section title="Detection">
                    <t>
                        Detection of an ongoing attack of this sort at a peer is
                        confounded difficult by the multiplexing features in
                        HTTP/2.  An attacker can permit the establishment of
                        entries in the header table, then block further
                        application data.  This prevents either peer from being
                        able to detect an attack.
                    </t>
                    <t>
                        On the client side, multiple attempts can be made to
                        guess values, up to the concurrency limit imposed by the
                        server in the SETTINGS_MAX_CONCURRENT_STREAMS setting.
                        On the server side, each guess in a response needs a
                        corresponding request.  However, with server push, the
                        only limit on the number of PUSH_PROMISE frames that can
                        be sent is the space available for server streams, which
                        permits up to 2<x:sup>30</x:sup> streams.
                        <list style="hanging">
                            <t hangText="Note:">
                                TCP acknowledgements are not authenticated,
                                which means that the TCP congestion window does
                                not limit the ability of an attacker to test
                                guesses up to these limits.
                            </t>
                        </list>
                    </t>
                    <t>
                        Beyond these limits, or for an entirely passive
                        attacker, attempts to guess header table state can be
                        detected by a peer.
                    </t>
                </section>

                <section title="Mitigation">
                    <t>
                        Users of HTTP that require confidentiality for header
                        fields can use values with entropy sufficient to make
                        guessing infeasible.  However, this is impractical as a
                        general solution because it forces all users of HTTP to
                        take steps to mitigate attacks.  It would impose new
                        constraints on how HTTP is used.
                    </t>
                    <t>
                        Rather than impose constraints on users of HTTP, an
                        implementation of HPACK can instead constrain how
                        compression is applied in order to limit the potential
                        for header table probing.
                    </t>
                    <t>
                        An ideal solution segregates access to the header table
                        based on the entity that is constructing header fields.
                        Header field values that are added to the table are
                        attributed to an entity, and only the entity that
                        created an particular value can extract that value.
                    </t>
                    <t>
                        To improve compression performance of this option,
                        certain entries might be tagged as being public.  For
                        example, a web browser might make the values of the
                        Accept-Encoding header field available in all requests.
                    </t>
                    <t>
                        An encoder without good knowledge of the provenance of
                        header fields might instead introduce a penalty for bad
                        guesses, such that attempts to guess a header field
                        value results in all values being removed from
                        consideration in all future requests, effectively
                        preventing further guesses.
                        <list style="hanging">
                            <t hangText="Note:">
                                Simply removing values from the header table can
                                be ineffectual if the attacker has a reliable
                                way of causing values to be reinstalled.  For
                                example, a request to load an image in a web
                                browser typically includes the Cookie header
                                field (a potentially highly valued target for
                                this sort of attack), and web sites can easily
                                force an image to be loaded, thereby refreshing
                                the entry in the header table.
                            </t>
                        </list>
                    </t>
                    <t>
                        This mitigation method might be deployed in proportion
                        to the inverse of the length of the header field.  That
                        is, shorter values might be marked as inaccessible more
                        quickly or with higher probability than longer values.
                        Note that length can be a poor proxy for entropy, as
                        some relatively long values, such as Date, contain
                        relatively low entropy.
                    </t>
                    <t>
                        Implementations might also choose to protect certain
                        header fields that are known to be highly valued, such
                        as the Authorization or Cookie header fields, by
                        disabling or further limiting compression.
                    </t>
                    <t>
                        Attacks using PUSH_PROMISE can be avoided by disabling
                        server push, or by having an intermediary refuse to
                        directly pass PUSH_PROMISE frames.  This limits attacks
                        on server state by the number of requests.
                    </t>
                </section>

                <section title="Never Indexed Literals">
                    <t>
                        Refusing to generate an indexed representation for a
                        header field might be ineffective if compression
                        reapplied by an intermediary.  The <xref
                        target="literal.header.never.indexed">never indexed
                        literal</xref> can be used to signal to an intermediary
                        that a particular value was intentionally sent as a
                        literal.  An intermediary MUST NOT use an indexed
                        representation for a value that uses the never indexed
                        literal representation.
                    </t>
                </section>
            </section>

            <section title="Static Huffman Encoding">
                <t>
                    There is currently no known threat taking advantage of the
                    use of a fixed Huffman encoding. A study has shown that
                    using a fixed Huffman encoding table created an
                    information leakage, however this same study concluded
                    that an attacker could not take advantage of this
                    information leakage to recover any meaningful amount of
                    information (see <xref target="PETAL"/>).
                </t>
            </section>

            <section title="Memory Consumption">
                <t>
                    An attacker can try to cause an endpoint to exhaust its
                    memory. HPACK is designed to limit both the peak and state
                    amounts of memory allocated by an endpoint.
                </t>
                <t>
                    The amount of memory used by the compressor state is
                    limited by the value of the HTTP/2 setting
                    SETTINGS_HEADER_TABLE_SIZE. This limitation takes into
                    account both the size of the data stored in the header
                    table, and the overhead required by the table structure
                    itself.
                </t>
                <t>
                    For the decoding side, an endpoint can limit the amount of
                    state memory used by setting an appropriate value for the
                    setting SETTINGS_HEADER_TABLE_SIZE. For the encoding side,
                    the endpoint can limit the amount of state memory it uses
                    by defining a header table maximum size lower than the
                    value of setting SETTINGS_HEADER_TABLE_SIZE defined by its
                    peer (see <xref target="encoding.context.update"/>).
                </t>
                <t>
                    The amount of temporary memory consumed is linked to the
                    set of header fields emitted or received. However, this
                    amount of temporary memory can be limited by processing
                    these header fields in a streaming manner.
                </t>
            </section>

            <section title="Implementation Limits">
                <t>
                    An implementation of HPACK needs to ensure that large
                    values for integers, long encoding for integers, or long
                    string literal do not create security weaknesses.
                </t>
                <t>
                    An implementation has to set a limit for the values it
                    accepts for integers, as well as for the encoded length
                    (see <xref target="integer.representation"/>).  In the
                    same way, it has to set a limit to the length it accepts
                    for string literals (see <xref
                        target="string.literal.representation"/>).
                </t>
            </section>

        </section>

        <section title="Acknowledgements">
            <t>
                This document includes substantial editorial contributions
                from the following individuals: Mike Bishop, Jeff Pinner,
                Julian Reschke, Martin Thomson.
            </t>
        </section>
    </middle>

    <back>
        <references title="Normative References">
            <reference anchor="HTTP2">
                <front>
                    <title>Hypertext Transfer Protocol version 2</title>
                    <author initials="M." surname="Belshe" fullname="Mike Belshe">
                        <organization>Twist</organization>
                    </author>
                    <author initials="R." surname="Peon" fullname="Roberto Peon">
                        <organization>Google</organization>
                    </author>
                    <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
                        <organization>Mozilla</organization>
                    </author>
                    <date month="April" year="2014"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-http2-12"/>
            </reference>

            <reference anchor="RFC7230">
              <front>
                <title>
                Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
                <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
                  <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
                  <address><email>fielding@gbiv.com</email></address>
                </author>
                <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
                  <organization abbrev="greenbytes">greenbytes GmbH</organization>
                  <address><email>julian.reschke@greenbytes.de</email></address>
                </author>
                <date month="June" year="2014" />
              </front>
              <seriesInfo name="RFC" value="7230" />
              <x:source href="refs/rfc7230.xml"
                basename="http://svn.tools.ietf.org/svn/wg/httpbis/specs/rfc7230"/>
            </reference>
        </references>

        <references title="Informative References">
            <reference anchor="SPDY">
                <front>
                    <title>SPDY Protocol</title>
                    <author initials="M." surname="Belshe" fullname="Mike Belshe">
                        <organization>Twist</organization>
                    </author>
                    <author initials="R." surname="Peon" fullname="Roberto Peon">
                        <organization>Google</organization>
                    </author>
                    <date month="February" year="2012"/>
                </front>
                <seriesInfo name="Internet-Draft" value="draft-mbelshe-httpbis-spdy-00"/>
            </reference>
            <reference anchor="ORIGIN">
                <front>
                    <title>The Web Origin Concept</title>
                    <author initials="A." surname="Barth" fullname="Adam Barth"/>
                    <date month="December" year="2011"/>
                </front>
                <seriesInfo name="RFC" value="6454"/>
            </reference>
            <reference anchor="DEFLATE">
                <front>
                    <title>DEFLATE Compressed Data Format Specification version 1.3</title>
                    <author initials="P." surname="Deutsch" fullname="L. Peter Deutsch">
                        <organization>Aladdin Enterprises</organization>
                    </author>
                    <date month="May" year="1996"/>
                </front>
                <seriesInfo name="RFC" value="1951"/>
            </reference>
            <reference anchor="CRIME" target="https://docs.google.com/a/twist.com/presentation/d/11eBmGiHbYcHR9gL5nDyZChu_-lCa2GizeuOfaLU2HOU/edit#slide=id.g1eb6c1b5_3_6">
                <front>
                    <title>The CRIME Attack</title>
                    <author initials="J." surname="Rizzo" fullname="Juliano Rizzo"></author>
                    <author initials="T." surname="Duong" fullname="Thai Duong"></author>
                    <date month="September" year="2012"/>
                </front>
            </reference>
            <reference anchor="PERF1" target="http://www.ietf.org/proceedings/83/slides/slides-83-httpbis-3">
                <front>
                    <title>IETF83: SPDY and What to Consider for HTTP/2.0</title>
                    <author initials="M." surname="Belshe" fullname="Mike Belshe">
                    </author>
                    <date month="March" year="2012"/>
                </front>
            </reference>
            <reference anchor="PERF2" target="http://bitsup.blogspot.com/2011/09/spdy-what-i-like-about-you.html">
                <front>
                    <title>SPDY: What I Like About You</title>
                    <author initials="P." surname="McManus" fullname="Patrick McManus">
                    </author>
                    <date month="September" year="2011"/>
                </front>
            </reference>

            <reference anchor="HUFF" target="http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=4051119">
                <front>
                    <title>A Method for the Construction of Minimum Redundancy Codes</title>
                    <author surname="Huffman" initials="D. A." fullname="David A. Huffman"/>
                    <date month="September" year="1952"/>
                </front>
                <seriesInfo name="Proceedings of the Institute of Radio Engineers" value="Volume 40, Number 9, pp. 1098-1101"/>
            </reference>

            <reference anchor="CANON" target="http://dl.acm.org/citation.cfm?id=363991">
                <front>
                    <title>Generating a canonical prefix encoding</title>
                    <author surname="Schwartz" initials="E. S." fullname="Eugene. S. Schwartz"/>
                    <author surname="Kallick" initials="B." fullname="Bruce Kallick"/>
                    <date month="March" year="1964"/>
                </front>
                <seriesInfo name="Communications of the ACM" value="Volume 7 Issue 3, pp. 166-169"/>
            </reference>

            <reference anchor="PETAL" target="http://www.pdl.cmu.edu/PDL-FTP/associated/CMU-PDL-13-106.pdf">
                <front>
                    <title>PETAL: Preset Encoding Table Information
                        Leakage</title>
                    <author surname="Tan" initials="J." fullname="Jiaqi Tan"/>
                    <author surname="Nahata" initials="J."
                        fullname="Jayvardhan Nahata"/>
                    <date month="April" year="2013"/>
                </front>
            </reference>
        </references>


        <section title="Change Log (to be removed by RFC Editor before publication">
            <section title="Since draft-ietf-httpbis-header-compression-07"
                anchor="changes.since.draft-ietf-httpbis-header-compression-07">
                <t><list style="symbols">
                    <t>
                        Removed old text on index value of 0.
                    </t>
                    <t>
                        Added clarification for signalling of maximum table
                        size after a SETTINGS_HEADER_TABLE_SIZE update.
                    </t>
                    <t>
                        Rewrote security considerations.
                    </t>
                </list></t>
            </section>
            <section title="Since draft-ietf-httpbis-header-compression-06"
                anchor="changes.since.draft-ietf-httpbis-header-compression-06">
                <t><list style="symbols">
                    <t>
                        Updated format to include literal headers that must
                        never be compressed.
                    </t>
                    <t>
                        Updated security considerations.
                    </t>
                    <t>
                        Moved integer encoding examples to the appendix.
                    </t>
                    <t>
                        Updated Huffman table.
                    </t>
                    <t>
                        Updated static header table (adding and removing
                        status values).
                    </t>
                    <t>
                        Updated examples.
                    </t>
                </list></t>
            </section>
            <section title="Since draft-ietf-httpbis-header-compression-05"
                anchor="changes.since.draft-ietf-httpbis-header-compression-05">
                <t><list style="symbols">
                    <t>
                        Regenerated examples.
                    </t>
                    <t>
                        Only one Huffman table for requests and responses.
                    </t>
                    <t>
                        Added maximum size for header table, independent of
                        SETTINGS_HEADER_TABLE_SIZE.
                    </t>
                    <t>
                        Added pseudo-code for integer decoding.
                    </t>
                    <t>
                        Improved examples (removing unnecessary removals).
                    </t>
                </list></t>
            </section>
            <section title="Since draft-ietf-httpbis-header-compression-04"
                anchor="changes.since.draft-ietf-httpbis-header-compression-04">
                <t><list style="symbols">
                    <t>
                        Updated examples: take into account changes in the
                        spec, and show more features.
                    </t>
                    <t>
                        Use 'octet' everywhere instead of having both 'byte'
                        and 'octet'.
                    </t>
                    <t>
                        Added reference set emptying.
                    </t>
                    <t>
                        Editorial changes and clarifications.
                    </t>
                    <t>
                        Added "host" header to the static table.
                    </t>
                    <t>
                        Ordering for list of values (either NULL- or
                        comma-separated).
                    </t>
                </list></t>
            </section>

            <section title="Since draft-ietf-httpbis-header-compression-03"
                anchor="changes.since.draft-ietf-httpbis-header-compression-03">
                <t><list style="symbols">
                    <t>
                        A large number of editorial changes; changed the
                        description of evicting/adding new entries.
                    </t>
                    <t>
                        Removed substitution indexing
                    </t>
                    <t>
                        Changed 'initial headers' to 'static headers', as per
                        issue #258
                    </t>
                    <t>
                        Merged 'request' and 'response' static headers, as per
                        issue #259
                    </t>
                    <t>
                        Changed text to indicate that new headers are added at
                        index 0 and expire from the largest index, as per
                        issue #233
                    </t>
                </list></t>
            </section>
            <section title="Since draft-ietf-httpbis-header-compression-02">
                <t><list style="symbols">
                    <t>
                        Corrected error in integer encoding pseudocode.
                    </t>
                </list></t>
            </section>

            <section title="Since draft-ietf-httpbis-header-compression-01">
                <t>
                    <list style="symbols">
                        <t>
                            Refactored of Header Encoding Section: split
                            definitions and processing rule.
                        </t>
                        <t>
                            Backward incompatible change: Updated
                            reference set management as per issue #214. This
                            changes how the interaction between the reference
                            set and eviction works. This also changes the
                            working of the reference set in some specific
                            cases.
                        </t>
                        <t>
                            Backward incompatible change: modified initial
                            header list, as per issue #188.
                        </t>
                        <t>
                            Added example of 32 octets entry structure (issue
                            #191).
                        </t>
                        <t>
                            Added Header Set Completion section.  Reflowed
                            some text. Clarified some writing which was
                            akward.  Added text about duplicate header entry
                            encoding.  Clarified some language w.r.t Header
                            Set.  Changed x-my-header to mynewheader. Added
                            text in the HeaderEmission section indicating that
                            the application may also be able to free up memory
                            more quickly.  Added information in Security
                            Considerations section.
                        </t>
                    </list>
                </t>
            </section>
            <section title="Since draft-ietf-httpbis-header-compression-00">
                <t>
                    <list>
                        <t>Fixed bug/omission in integer representation algorithm.</t>
                        <t>Changed the document title.</t>
                        <t>Header matching text rewritten.</t>
                        <t>Changed the definition of header emission.</t>
                        <t>Changed the name of the setting which dictates how
                            much memory the compression context should
                            use.</t>
                        <t>Removed "specific use cases" section</t>
                        <t>Corrected erroneous statement about what index can
                            be contained in one octet</t>
                        <t>Added descriptions of opcodes</t>
                        <t>Removed security claims from introduction.</t>
                    </list>
                </t>
            </section>
        </section>
        <section title="Static Table" anchor="static.table">
            <t>
                The static table consists of an unchangeable ordered list of
                (name, value) pairs. The first entry in the table is always
                represented by the index len(header table) + 1, and the last entry
                in the table is represented by the index len(header
                table) + len(static table).
            </t>
            <t>
                The following table lists the pre-defined header fields that
                make-up the static table.
            </t>
            <texttable title="Static Table Entries"
                anchor="static.table.entries">
                <!-- An easy way to renumber these in vim, with mark a and b
                     delimiting the table entries:
                      :let @a=1 | 'a,'bs/>[0-9 ][0-9 ]*</\='>'.(@a+setreg('a',@a+1)).'<'/
                    -->
                    <ttcol>Index</ttcol>
                    <ttcol>Header Name</ttcol>
                    <ttcol>Header Value</ttcol>

                    <c>1</c><c>:authority</c><c></c>
                    <c>2</c><c>:method</c><c>GET</c>
                    <c>3</c><c>:method</c><c>POST</c>
                    <c>4</c><c>:path</c><c>/</c>
                    <c>5</c><c>:path</c><c>/index.html</c>
                    <c>6</c><c>:scheme</c><c>http</c>
                    <c>7</c><c>:scheme</c><c>https</c>
                    <c>8</c><c>:status</c><c>200</c>
                    <c>9</c><c>:status</c><c>204</c>
                    <c>10</c><c>:status</c><c>206</c>
                    <c>11</c><c>:status</c><c>304</c>
                    <c>12</c><c>:status</c><c>400</c>
                    <c>13</c><c>:status</c><c>404</c>
                    <c>14</c><c>:status</c><c>500</c>
                    <c>15</c><c>accept-charset</c><c></c>
                    <c>16</c><c>accept-encoding</c><c></c>
                    <c>17</c><c>accept-language</c><c></c>
                    <c>18</c><c>accept-ranges</c><c></c>
                    <c>19</c><c>accept</c><c></c>
                    <c>20</c><c>access-control-allow-origin</c><c></c>
                    <c>21</c><c>age</c><c></c>
                    <c>22</c><c>allow</c><c></c>
                    <c>23</c><c>authorization</c><c></c>
                    <c>24</c><c>cache-control</c><c></c>
                    <c>25</c><c>content-disposition</c><c></c>
                    <c>26</c><c>content-encoding</c><c></c>
                    <c>27</c><c>content-language</c><c></c>
                    <c>28</c><c>content-length</c><c></c>
                    <c>29</c><c>content-location</c><c></c>
                    <c>30</c><c>content-range</c><c></c>
                    <c>31</c><c>content-type</c><c></c>
                    <c>32</c><c>cookie</c><c></c>
                    <c>33</c><c>date</c><c></c>
                    <c>34</c><c>etag</c><c></c>
                    <c>35</c><c>expect</c><c></c>
                    <c>36</c><c>expires</c><c></c>
                    <c>37</c><c>from</c><c></c>
                    <c>38</c><c>host</c><c></c>
                    <c>39</c><c>if-match</c><c></c>
                    <c>40</c><c>if-modified-since</c><c></c>
                    <c>41</c><c>if-none-match</c><c></c>
                    <c>42</c><c>if-range</c><c></c>
                    <c>43</c><c>if-unmodified-since</c><c></c>
                    <c>44</c><c>last-modified</c><c></c>
                    <c>45</c><c>link</c><c></c>
                    <c>46</c><c>location</c><c></c>
                    <c>47</c><c>max-forwards</c><c></c>
                    <c>48</c><c>proxy-authenticate</c><c></c>
                    <c>49</c><c>proxy-authorization</c><c></c>
                    <c>50</c><c>range</c><c></c>
                    <c>51</c><c>referer</c><c></c>
                    <c>52</c><c>refresh</c><c></c>
                    <c>53</c><c>retry-after</c><c></c>
                    <c>54</c><c>server</c><c></c>
                    <c>55</c><c>set-cookie</c><c></c>
                    <c>56</c><c>strict-transport-security</c><c></c>
                    <c>57</c><c>transfer-encoding</c><c></c>
                    <c>58</c><c>user-agent</c><c></c>
                    <c>59</c><c>vary</c><c></c>
                    <c>60</c><c>via</c><c></c>
                    <c>61</c><c>www-authenticate</c><c></c>
                </texttable>
            <t>
                The table give the index of each entry in the static table.
                The full index of each entry, to be used for encoding a
                reference to this entry, is computed by adding the number of
                entries in the header table to this index.
            </t>
        </section>

        <section title="Huffman Codes" anchor="huffman.codes">
            <t>
                The following codes are used when encoding string
                literals with an Huffman coding (see <xref
                    target="string.literal.representation"/>).
            </t>
            <t>
                Each row in the table specifies one Huffman code:
                <list style="hanging">
                    <t hangText="sym:">
                        The symbol to be represented. It is the decimal value
                        of an octet, possibly prepended with its ASCII
                        representation. A specific symbol, "EOS", is used to
                        indicate the end of a string literal.
                    </t>
                    <t hangText="code as bits:">
                        The Huffman code for the symbol represented as a
                        base-2 integer.
                    </t>
                    <t hangText="code as hex:">
                        The Huffman code for the symbol, represented as a
                        hexadecimal integer, aligned on the least significant
                        bit.
                    </t>
                    <t hangText="len:">
                        The number of bits for the Huffman code of the symbol.
                    </t>
                </list>
            </t>
            <t>
                As an example, the Huffman code for the symbol 47
                (corresponding to the ASCII character "/") consists in the 5
                bits "0", "0", "1", "1", "1". This corresponds to the value 7
                encoded on 5 bits.
            </t>
            <t>
                <figure>
                    <artwork><![CDATA[
                                            code
                    code as bits           as hex   len
     sym           aligned to MSB          aligned   in
                                           to LSB   bits
    (  0)  |11111111|11111111|11101110|10  3ffffba  [26]
    (  1)  |11111111|11111111|11101110|11  3ffffbb  [26]
    (  2)  |11111111|11111111|11101111|00  3ffffbc  [26]
    (  3)  |11111111|11111111|11101111|01  3ffffbd  [26]
    (  4)  |11111111|11111111|11101111|10  3ffffbe  [26]
    (  5)  |11111111|11111111|11101111|11  3ffffbf  [26]
    (  6)  |11111111|11111111|11110000|00  3ffffc0  [26]
    (  7)  |11111111|11111111|11110000|01  3ffffc1  [26]
    (  8)  |11111111|11111111|11110000|10  3ffffc2  [26]
    (  9)  |11111111|11111111|11110000|11  3ffffc3  [26]
    ( 10)  |11111111|11111111|11110001|00  3ffffc4  [26]
    ( 11)  |11111111|11111111|11110001|01  3ffffc5  [26]
    ( 12)  |11111111|11111111|11110001|10  3ffffc6  [26]
    ( 13)  |11111111|11111111|11110001|11  3ffffc7  [26]
    ( 14)  |11111111|11111111|11110010|00  3ffffc8  [26]
    ( 15)  |11111111|11111111|11110010|01  3ffffc9  [26]
    ( 16)  |11111111|11111111|11110010|10  3ffffca  [26]
    ( 17)  |11111111|11111111|11110010|11  3ffffcb  [26]
    ( 18)  |11111111|11111111|11110011|00  3ffffcc  [26]
    ( 19)  |11111111|11111111|11110011|01  3ffffcd  [26]
    ( 20)  |11111111|11111111|11110011|10  3ffffce  [26]
    ( 21)  |11111111|11111111|11110011|11  3ffffcf  [26]
    ( 22)  |11111111|11111111|11110100|00  3ffffd0  [26]
    ( 23)  |11111111|11111111|11110100|01  3ffffd1  [26]
    ( 24)  |11111111|11111111|11110100|10  3ffffd2  [26]
    ( 25)  |11111111|11111111|11110100|11  3ffffd3  [26]
    ( 26)  |11111111|11111111|11110101|00  3ffffd4  [26]
    ( 27)  |11111111|11111111|11110101|01  3ffffd5  [26]
    ( 28)  |11111111|11111111|11110101|10  3ffffd6  [26]
    ( 29)  |11111111|11111111|11110101|11  3ffffd7  [26]
    ( 30)  |11111111|11111111|11110110|00  3ffffd8  [26]
    ( 31)  |11111111|11111111|11110110|01  3ffffd9  [26]
' ' ( 32)  |00110                                6  [ 5]
'!' ( 33)  |11111111|11100                    1ffc  [13]
'"' ( 34)  |11111000|0                         1f0  [ 9]
'#' ( 35)  |11111111|111100                   3ffc  [14]
'$' ( 36)  |11111111|1111100                  7ffc  [15]
'%' ( 37)  |011110                              1e  [ 6]
'&' ( 38)  |1100100                             64  [ 7]
''' ( 39)  |11111111|11101                    1ffd  [13]
'(' ( 40)  |11111110|10                        3fa  [10]
')' ( 41)  |11111000|1                         1f1  [ 9]
'*' ( 42)  |11111110|11                        3fb  [10]
'+' ( 43)  |11111111|00                        3fc  [10]
',' ( 44)  |1100101                             65  [ 7]
'-' ( 45)  |1100110                             66  [ 7]
'.' ( 46)  |011111                              1f  [ 6]
'/' ( 47)  |00111                                7  [ 5]
'0' ( 48)  |0000                                 0  [ 4]
'1' ( 49)  |0001                                 1  [ 4]
'2' ( 50)  |0010                                 2  [ 4]
'3' ( 51)  |01000                                8  [ 5]
'4' ( 52)  |100000                              20  [ 6]
'5' ( 53)  |100001                              21  [ 6]
'6' ( 54)  |100010                              22  [ 6]
'7' ( 55)  |100011                              23  [ 6]
'8' ( 56)  |100100                              24  [ 6]
'9' ( 57)  |100101                              25  [ 6]
':' ( 58)  |100110                              26  [ 6]
';' ( 59)  |11101100|                           ec  [ 8]
'<' ( 60)  |11111111|11111110|0              1fffc  [17]
'=' ( 61)  |100111                              27  [ 6]
'>' ( 62)  |11111111|1111101                  7ffd  [15]
'?' ( 63)  |11111111|01                        3fd  [10]
'@' ( 64)  |11111111|1111110                  7ffe  [15]
'A' ( 65)  |1100111                             67  [ 7]
'B' ( 66)  |11101101|                           ed  [ 8]
'C' ( 67)  |11101110|                           ee  [ 8]
'D' ( 68)  |1101000                             68  [ 7]
'E' ( 69)  |11101111|                           ef  [ 8]
'F' ( 70)  |1101001                             69  [ 7]
'G' ( 71)  |1101010                             6a  [ 7]
'H' ( 72)  |11111001|0                         1f2  [ 9]
'I' ( 73)  |11110000|                           f0  [ 8]
'J' ( 74)  |11111001|1                         1f3  [ 9]
'K' ( 75)  |11111010|0                         1f4  [ 9]
'L' ( 76)  |11111010|1                         1f5  [ 9]
'M' ( 77)  |1101011                             6b  [ 7]
'N' ( 78)  |1101100                             6c  [ 7]
'O' ( 79)  |11110001|                           f1  [ 8]
'P' ( 80)  |11110010|                           f2  [ 8]
'Q' ( 81)  |11111011|0                         1f6  [ 9]
'R' ( 82)  |11111011|1                         1f7  [ 9]
'S' ( 83)  |1101101                             6d  [ 7]
'T' ( 84)  |101000                              28  [ 6]
'U' ( 85)  |11110011|                           f3  [ 8]
'V' ( 86)  |11111100|0                         1f8  [ 9]
'W' ( 87)  |11111100|1                         1f9  [ 9]
'X' ( 88)  |11110100|                           f4  [ 8]
'Y' ( 89)  |11111101|0                         1fa  [ 9]
'Z' ( 90)  |11111101|1                         1fb  [ 9]
'[' ( 91)  |11111111|100                       7fc  [11]
'\' ( 92)  |11111111|11111111|11110110|10  3ffffda  [26]
']' ( 93)  |11111111|101                       7fd  [11]
'^' ( 94)  |11111111|111101                   3ffd  [14]
'_' ( 95)  |1101110                             6e  [ 7]
'`' ( 96)  |11111111|11111111|10             3fffe  [18]
'a' ( 97)  |01001                                9  [ 5]
'b' ( 98)  |1101111                             6f  [ 7]
'c' ( 99)  |01010                                a  [ 5]
'd' (100)  |101001                              29  [ 6]
'e' (101)  |01011                                b  [ 5]
'f' (102)  |1110000                             70  [ 7]
'g' (103)  |101010                              2a  [ 6]
'h' (104)  |101011                              2b  [ 6]
'i' (105)  |01100                                c  [ 5]
'j' (106)  |11110101|                           f5  [ 8]
'k' (107)  |11110110|                           f6  [ 8]
'l' (108)  |101100                              2c  [ 6]
'm' (109)  |101101                              2d  [ 6]
'n' (110)  |101110                              2e  [ 6]
'o' (111)  |01101                                d  [ 5]
'p' (112)  |101111                              2f  [ 6]
'q' (113)  |11111110|0                         1fc  [ 9]
'r' (114)  |110000                              30  [ 6]
's' (115)  |110001                              31  [ 6]
't' (116)  |01110                                e  [ 5]
'u' (117)  |1110001                             71  [ 7]
'v' (118)  |1110010                             72  [ 7]
'w' (119)  |1110011                             73  [ 7]
'x' (120)  |1110100                             74  [ 7]
'y' (121)  |1110101                             75  [ 7]
'z' (122)  |11110111|                           f7  [ 8]
'{' (123)  |11111111|11111110|1              1fffd  [17]
'|' (124)  |11111111|1100                      ffc  [12]
'}' (125)  |11111111|11111111|0              1fffe  [17]
'~' (126)  |11111111|1101                      ffd  [12]
    (127)  |11111111|11111111|11110110|11  3ffffdb  [26]
    (128)  |11111111|11111111|11110111|00  3ffffdc  [26]
    (129)  |11111111|11111111|11110111|01  3ffffdd  [26]
    (130)  |11111111|11111111|11110111|10  3ffffde  [26]
    (131)  |11111111|11111111|11110111|11  3ffffdf  [26]
    (132)  |11111111|11111111|11111000|00  3ffffe0  [26]
    (133)  |11111111|11111111|11111000|01  3ffffe1  [26]
    (134)  |11111111|11111111|11111000|10  3ffffe2  [26]
    (135)  |11111111|11111111|11111000|11  3ffffe3  [26]
    (136)  |11111111|11111111|11111001|00  3ffffe4  [26]
    (137)  |11111111|11111111|11111001|01  3ffffe5  [26]
    (138)  |11111111|11111111|11111001|10  3ffffe6  [26]
    (139)  |11111111|11111111|11111001|11  3ffffe7  [26]
    (140)  |11111111|11111111|11111010|00  3ffffe8  [26]
    (141)  |11111111|11111111|11111010|01  3ffffe9  [26]
    (142)  |11111111|11111111|11111010|10  3ffffea  [26]
    (143)  |11111111|11111111|11111010|11  3ffffeb  [26]
    (144)  |11111111|11111111|11111011|00  3ffffec  [26]
    (145)  |11111111|11111111|11111011|01  3ffffed  [26]
    (146)  |11111111|11111111|11111011|10  3ffffee  [26]
    (147)  |11111111|11111111|11111011|11  3ffffef  [26]
    (148)  |11111111|11111111|11111100|00  3fffff0  [26]
    (149)  |11111111|11111111|11111100|01  3fffff1  [26]
    (150)  |11111111|11111111|11111100|10  3fffff2  [26]
    (151)  |11111111|11111111|11111100|11  3fffff3  [26]
    (152)  |11111111|11111111|11111101|00  3fffff4  [26]
    (153)  |11111111|11111111|11111101|01  3fffff5  [26]
    (154)  |11111111|11111111|11111101|10  3fffff6  [26]
    (155)  |11111111|11111111|11111101|11  3fffff7  [26]
    (156)  |11111111|11111111|11111110|00  3fffff8  [26]
    (157)  |11111111|11111111|11111110|01  3fffff9  [26]
    (158)  |11111111|11111111|11111110|10  3fffffa  [26]
    (159)  |11111111|11111111|11111110|11  3fffffb  [26]
    (160)  |11111111|11111111|11111111|00  3fffffc  [26]
    (161)  |11111111|11111111|11111111|01  3fffffd  [26]
    (162)  |11111111|11111111|11111111|10  3fffffe  [26]
    (163)  |11111111|11111111|11111111|11  3ffffff  [26]
    (164)  |11111111|11111111|11000000|0   1ffff80  [25]
    (165)  |11111111|11111111|11000000|1   1ffff81  [25]
    (166)  |11111111|11111111|11000001|0   1ffff82  [25]
    (167)  |11111111|11111111|11000001|1   1ffff83  [25]
    (168)  |11111111|11111111|11000010|0   1ffff84  [25]
    (169)  |11111111|11111111|11000010|1   1ffff85  [25]
    (170)  |11111111|11111111|11000011|0   1ffff86  [25]
    (171)  |11111111|11111111|11000011|1   1ffff87  [25]
    (172)  |11111111|11111111|11000100|0   1ffff88  [25]
    (173)  |11111111|11111111|11000100|1   1ffff89  [25]
    (174)  |11111111|11111111|11000101|0   1ffff8a  [25]
    (175)  |11111111|11111111|11000101|1   1ffff8b  [25]
    (176)  |11111111|11111111|11000110|0   1ffff8c  [25]
    (177)  |11111111|11111111|11000110|1   1ffff8d  [25]
    (178)  |11111111|11111111|11000111|0   1ffff8e  [25]
    (179)  |11111111|11111111|11000111|1   1ffff8f  [25]
    (180)  |11111111|11111111|11001000|0   1ffff90  [25]
    (181)  |11111111|11111111|11001000|1   1ffff91  [25]
    (182)  |11111111|11111111|11001001|0   1ffff92  [25]
    (183)  |11111111|11111111|11001001|1   1ffff93  [25]
    (184)  |11111111|11111111|11001010|0   1ffff94  [25]
    (185)  |11111111|11111111|11001010|1   1ffff95  [25]
    (186)  |11111111|11111111|11001011|0   1ffff96  [25]
    (187)  |11111111|11111111|11001011|1   1ffff97  [25]
    (188)  |11111111|11111111|11001100|0   1ffff98  [25]
    (189)  |11111111|11111111|11001100|1   1ffff99  [25]
    (190)  |11111111|11111111|11001101|0   1ffff9a  [25]
    (191)  |11111111|11111111|11001101|1   1ffff9b  [25]
    (192)  |11111111|11111111|11001110|0   1ffff9c  [25]
    (193)  |11111111|11111111|11001110|1   1ffff9d  [25]
    (194)  |11111111|11111111|11001111|0   1ffff9e  [25]
    (195)  |11111111|11111111|11001111|1   1ffff9f  [25]
    (196)  |11111111|11111111|11010000|0   1ffffa0  [25]
    (197)  |11111111|11111111|11010000|1   1ffffa1  [25]
    (198)  |11111111|11111111|11010001|0   1ffffa2  [25]
    (199)  |11111111|11111111|11010001|1   1ffffa3  [25]
    (200)  |11111111|11111111|11010010|0   1ffffa4  [25]
    (201)  |11111111|11111111|11010010|1   1ffffa5  [25]
    (202)  |11111111|11111111|11010011|0   1ffffa6  [25]
    (203)  |11111111|11111111|11010011|1   1ffffa7  [25]
    (204)  |11111111|11111111|11010100|0   1ffffa8  [25]
    (205)  |11111111|11111111|11010100|1   1ffffa9  [25]
    (206)  |11111111|11111111|11010101|0   1ffffaa  [25]
    (207)  |11111111|11111111|11010101|1   1ffffab  [25]
    (208)  |11111111|11111111|11010110|0   1ffffac  [25]
    (209)  |11111111|11111111|11010110|1   1ffffad  [25]
    (210)  |11111111|11111111|11010111|0   1ffffae  [25]
    (211)  |11111111|11111111|11010111|1   1ffffaf  [25]
    (212)  |11111111|11111111|11011000|0   1ffffb0  [25]
    (213)  |11111111|11111111|11011000|1   1ffffb1  [25]
    (214)  |11111111|11111111|11011001|0   1ffffb2  [25]
    (215)  |11111111|11111111|11011001|1   1ffffb3  [25]
    (216)  |11111111|11111111|11011010|0   1ffffb4  [25]
    (217)  |11111111|11111111|11011010|1   1ffffb5  [25]
    (218)  |11111111|11111111|11011011|0   1ffffb6  [25]
    (219)  |11111111|11111111|11011011|1   1ffffb7  [25]
    (220)  |11111111|11111111|11011100|0   1ffffb8  [25]
    (221)  |11111111|11111111|11011100|1   1ffffb9  [25]
    (222)  |11111111|11111111|11011101|0   1ffffba  [25]
    (223)  |11111111|11111111|11011101|1   1ffffbb  [25]
    (224)  |11111111|11111111|11011110|0   1ffffbc  [25]
    (225)  |11111111|11111111|11011110|1   1ffffbd  [25]
    (226)  |11111111|11111111|11011111|0   1ffffbe  [25]
    (227)  |11111111|11111111|11011111|1   1ffffbf  [25]
    (228)  |11111111|11111111|11100000|0   1ffffc0  [25]
    (229)  |11111111|11111111|11100000|1   1ffffc1  [25]
    (230)  |11111111|11111111|11100001|0   1ffffc2  [25]
    (231)  |11111111|11111111|11100001|1   1ffffc3  [25]
    (232)  |11111111|11111111|11100010|0   1ffffc4  [25]
    (233)  |11111111|11111111|11100010|1   1ffffc5  [25]
    (234)  |11111111|11111111|11100011|0   1ffffc6  [25]
    (235)  |11111111|11111111|11100011|1   1ffffc7  [25]
    (236)  |11111111|11111111|11100100|0   1ffffc8  [25]
    (237)  |11111111|11111111|11100100|1   1ffffc9  [25]
    (238)  |11111111|11111111|11100101|0   1ffffca  [25]
    (239)  |11111111|11111111|11100101|1   1ffffcb  [25]
    (240)  |11111111|11111111|11100110|0   1ffffcc  [25]
    (241)  |11111111|11111111|11100110|1   1ffffcd  [25]
    (242)  |11111111|11111111|11100111|0   1ffffce  [25]
    (243)  |11111111|11111111|11100111|1   1ffffcf  [25]
    (244)  |11111111|11111111|11101000|0   1ffffd0  [25]
    (245)  |11111111|11111111|11101000|1   1ffffd1  [25]
    (246)  |11111111|11111111|11101001|0   1ffffd2  [25]
    (247)  |11111111|11111111|11101001|1   1ffffd3  [25]
    (248)  |11111111|11111111|11101010|0   1ffffd4  [25]
    (249)  |11111111|11111111|11101010|1   1ffffd5  [25]
    (250)  |11111111|11111111|11101011|0   1ffffd6  [25]
    (251)  |11111111|11111111|11101011|1   1ffffd7  [25]
    (252)  |11111111|11111111|11101100|0   1ffffd8  [25]
    (253)  |11111111|11111111|11101100|1   1ffffd9  [25]
    (254)  |11111111|11111111|11101101|0   1ffffda  [25]
    (255)  |11111111|11111111|11101101|1   1ffffdb  [25]
EOS (256)  |11111111|11111111|11101110|0   1ffffdc  [25]
]]></artwork>
                </figure>
            </t>
        </section>


        <section title="Examples" anchor="examples">
            <t>
                A number of examples are worked through here, covering integer
                encoding, header field representation, and the encoding of
                whole sets of header fields, for both requests and responses,
                and with and without Huffman coding.
            </t>

            <section title="Integer Representation Examples"
                anchor="integer.representation.examples">
                <t>
                    This section shows the representation of integer values in
                    details (see <xref target="integer.representation"/>).
                </t>
                <section title="Example 1: Encoding 10 using a 5-bit prefix"
                    anchor="integer.representation.example1">
                    <t>
                        The value 10 is to be encoded with a 5-bit prefix.
                        <list style="symbols">
                            <t>
                                10 is less than 31 (2<x:sup>5</x:sup> -
                                1) and is represented using the 5-bit
                                prefix.
                            </t>
                        </list>
                    </t>
                    <figure>
                        <artwork><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 0 | 1 | 0 | 1 | 0 |   10 stored on 5 bits
+---+---+---+---+---+---+---+---+
]]></artwork>
                    </figure>
                </section>

                <section title="Example 2: Encoding 1337 using a 5-bit prefix"
                    anchor="integer.representation.example2">
                    <t>
                        The value I=1337 is to be encoded with a 5-bit
                        prefix.
                        <list>
                            <t>
                                1337 is greater than 31 (2<x:sup>5</x:sup> -
                                1).
                            </t>
                            <t>
                                <list>
                                    <t>The 5-bit prefix is filled with its
                                        max value (31).</t>
                                </list>
                            </t>
                            <t>I = 1337 - (2<x:sup>5</x:sup> - 1) =
                                1306.</t>
                            <t>
                                <list>
                                    <t>I (1306) is greater than or equal
                                        to 128, the while loop body
                                        executes:</t>
                                    <t>
                                        <list>
                                            <t>I % 128 == 26</t>
                                            <t>26 + 128 == 154</t>
                                            <t>154 is encoded in 8 bits as:
                                                10011010</t>
                                            <t>I is set to 10 (1306 / 128 ==
                                                10)</t>
                                            <t>I is no longer greater than
                                                or equal to 128, the while
                                                loop terminates.</t>
                                        </list>
                                    </t>
                                    <t>
                                        I, now 10, is encoded on 8 bits
                                        as: 00001010.
                                    </t>
                                </list>
                            </t>

                            <t>The process ends.</t>
                        </list>

                    </t>
                    <figure>
                        <artwork><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| X | X | X | 1 | 1 | 1 | 1 | 1 |  Prefix = 31, I = 1306
| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |  1306>=128, encode(154), I=1306/128
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |  10<128, encode(10), done
+---+---+---+---+---+---+---+---+
]]></artwork>
                    </figure>
                </section>

                <section title="Example 3: Encoding 42 starting at an
                    octet-boundary"
                    anchor="integer.representation.example3">
                    <t>
                        The value 42 is to be encoded starting at an
                        octet-boundary. This implies that a 8-bit prefix is
                        used.
                        <list style="symbols">
                            <t>
                                42 is less than 255 (2<x:sup>8</x:sup> -
                                1) and is represented using the 8-bit
                                prefix.
                            </t>
                        </list>
                    </t>
                    <figure>
                        <artwork><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |   42 stored on 8 bits
+---+---+---+---+---+---+---+---+
]]></artwork>
                    </figure>
                </section>
            </section>

<!-- example-start -->
<section title="Header Field Representation Examples"
    anchor="header.field.representation.examples">
    <t>
        This section shows several independent representation examples.
    </t>
    <section title="Literal Header Field with Indexing">
        <t>
            The header field representation uses a literal name and a literal value.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[custom-key: custom-header]]></artwork>
            </figure>
        </t>
        <t>
            Reference set: empty.
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[400a 6375 7374 6f6d 2d6b 6579 0d63 7573 | @.custom-key.cus
746f 6d2d 6865 6164 6572                | tom-header]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[40                                      | == Literal indexed ==
0a                                      |   Literal name (len = 10)
6375 7374 6f6d 2d6b 6579                | custom-key
0d                                      |   Literal value (len = 13)
6375 7374 6f6d 2d68 6561 6465 72        | custom-header
                                        | -> custom-key: custom-head\
                                        |   er]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  55) custom-key: custom-header
      Table size:  55]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[custom-key: custom-header]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Literal Header Field without Indexing">
        <t>
            The header field representation uses an indexed name and a literal value.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:path: /sample/path]]></artwork>
            </figure>
        </t>
        <t>
            Reference set: empty.
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[040c 2f73 616d 706c 652f 7061 7468      | ../sample/path]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[04                                      | == Literal not indexed ==
                                        |   Indexed name (idx = 4)
                                        |     :path
0c                                      |   Literal value (len = 12)
2f73 616d 706c 652f 7061 7468           | /sample/path
                                        | -> :path: /sample/path]]></artwork>
            </figure>
        </t>
        <t>
          Header table (after decoding): empty.
      </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:path: /sample/path]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Indexed Header Field">
        <t>
            The header field representation uses an indexed header field, from
the static table. Upon using it, the static table entry is copied into
the header table.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:method: GET]]></artwork>
            </figure>
        </t>
        <t>
            Reference set: empty.
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[82                                      | .]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  42) :method: GET
      Table size:  42]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:method: GET]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Indexed Header Field from Static Table">
        <t>
            The header field representation uses an indexed header field, from
the static table. In this example, the HTTP/2 setting
SETTINGS_HEADER_TABLE_SIZE is set to 0, therefore, the entry is not copied
into the header table.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:method: GET]]></artwork>
            </figure>
        </t>
        <t>
            Reference set: empty.
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[82                                      | .]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET]]></artwork>
            </figure>
        </t>
        <t>
          Header table (after decoding): empty.
      </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:method: GET]]></artwork>
            </figure>
        </t>
    </section>

</section>
<section title="Request Examples without Huffman"
    anchor="request.examples.without.huffman">
    <t>
        This section shows several consecutive header sets, corresponding
to HTTP requests, on the same connection.
    </t>
    <section title="First request">
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            Reference set: empty.
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8287 8644 0f77 7777 2e65 7861 6d70 6c65 | ...D.www.example
2e63 6f6d                               | .com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET
87                                      | == Indexed - Add ==
                                        |   idx = 7
                                        | -> :scheme: http
86                                      | == Indexed - Add ==
                                        |   idx = 6
                                        | -> :path: /
44                                      | == Literal indexed ==
                                        |   Indexed name (idx = 4)
                                        |     :authority
0f                                      |   Literal value (len = 15)
7777 772e 6578 616d 706c 652e 636f 6d   | www.example.com
                                        | -> :authority: www.example\
                                        |   .com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  57) :authority: www.example.com
[  2] (s =  38) :path: /
[  3] (s =  43) :scheme: http
[  4] (s =  42) :method: GET
      Table size: 180]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Second request">
        <t>
            This request takes advantage of the differential encoding of header sets.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com
cache-control: no-cache]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Reference set:</preamble>
                <artwork>
<![CDATA[[  1] :authority: www.example.com
[  2] :path: /
[  3] :scheme: http
[  4] :method: GET]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[5c08 6e6f 2d63 6163 6865                | \.no-cache]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[5c                                      | == Literal indexed ==
                                        |   Indexed name (idx = 28)
                                        |     cache-control
08                                      |   Literal value (len = 8)
6e6f 2d63 6163 6865                     | no-cache
                                        | -> cache-control: no-cache]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  53) cache-control: no-cache
[  2] (s =  57) :authority: www.example.com
[  3] (s =  38) :path: /
[  4] (s =  43) :scheme: http
[  5] (s =  42) :method: GET
      Table size: 233]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[cache-control: no-cache
:authority: www.example.com
:path: /
:scheme: http
:method: GET]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Third request">
        <t>
            This request has not enough headers in common with the previous request
to take advantage of the differential encoding. Therefore, the reference set
is emptied before encoding the header fields.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: https
:path: /index.html
:authority: www.example.com
custom-key: custom-value]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Reference set:</preamble>
                <artwork>
<![CDATA[[  1] cache-control: no-cache
[  2] :authority: www.example.com
[  3] :path: /
[  4] :scheme: http
[  5] :method: GET]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[3085 8c8b 8440 0a63 7573 746f 6d2d 6b65 | 0....@.custom-ke
790c 6375 7374 6f6d 2d76 616c 7565      | y.custom-value]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[30                                      | == Empty reference set ==
                                        |   idx = 0
                                        |   flag = 1
85                                      | == Indexed - Add ==
                                        |   idx = 5
                                        | -> :method: GET
8c                                      | == Indexed - Add ==
                                        |   idx = 12
                                        | -> :scheme: https
8b                                      | == Indexed - Add ==
                                        |   idx = 11
                                        | -> :path: /index.html
84                                      | == Indexed - Add ==
                                        |   idx = 4
                                        | -> :authority: www.example\
                                        |   .com
40                                      | == Literal indexed ==
0a                                      |   Literal name (len = 10)
6375 7374 6f6d 2d6b 6579                | custom-key
0c                                      |   Literal value (len = 12)
6375 7374 6f6d 2d76 616c 7565           | custom-value
                                        | -> custom-key: custom-valu\
                                        |   e]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  54) custom-key: custom-value
[  2] (s =  48) :path: /index.html
[  3] (s =  44) :scheme: https
[  4] (s =  53) cache-control: no-cache
[  5] (s =  57) :authority: www.example.com
[  6] (s =  38) :path: /
[  7] (s =  43) :scheme: http
[  8] (s =  42) :method: GET
      Table size: 379]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: https
:path: /index.html
:authority: www.example.com
custom-key: custom-value]]></artwork>
            </figure>
        </t>
    </section>

</section>
<section title="Request Examples with Huffman"
    anchor="request.examples.with.huffman">
    <t>
        This section shows the same examples as the previous section, but
using Huffman encoding for the literal values.
    </t>
    <section title="First request">
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            Reference set: empty.
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8287 8644 8ce7 cf9b ebe8 9b6f b16f a9b6 | ...D.......o.o..
ff                                      | .]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[82                                      | == Indexed - Add ==
                                        |   idx = 2
                                        | -> :method: GET
87                                      | == Indexed - Add ==
                                        |   idx = 7
                                        | -> :scheme: http
86                                      | == Indexed - Add ==
                                        |   idx = 6
                                        | -> :path: /
44                                      | == Literal indexed ==
                                        |   Indexed name (idx = 4)
                                        |     :authority
8c                                      |   Literal value (len = 15)
                                        |     Huffman encoded:
e7cf 9beb e89b 6fb1 6fa9 b6ff           | ......o.o...
                                        |     Decoded:
                                        | www.example.com
                                        | -> :authority: www.example\
                                        |   .com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  57) :authority: www.example.com
[  2] (s =  38) :path: /
[  3] (s =  43) :scheme: http
[  4] (s =  42) :method: GET
      Table size: 180]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Second request">
        <t>
            This request takes advantage of the differential encoding of header sets.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: http
:path: /
:authority: www.example.com
cache-control: no-cache]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Reference set:</preamble>
                <artwork>
<![CDATA[[  1] :authority: www.example.com
[  2] :path: /
[  3] :scheme: http
[  4] :method: GET]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[5c86 b9b9 9495 56bf                     | \.....V.]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[5c                                      | == Literal indexed ==
                                        |   Indexed name (idx = 28)
                                        |     cache-control
86                                      |   Literal value (len = 8)
                                        |     Huffman encoded:
b9b9 9495 56bf                          | ....V.
                                        |     Decoded:
                                        | no-cache
                                        | -> cache-control: no-cache]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  53) cache-control: no-cache
[  2] (s =  57) :authority: www.example.com
[  3] (s =  38) :path: /
[  4] (s =  43) :scheme: http
[  5] (s =  42) :method: GET
      Table size: 233]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[cache-control: no-cache
:authority: www.example.com
:path: /
:scheme: http
:method: GET]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Third request">
        <t>
            This request has not enough headers in common with the previous request
to take advantage of the differential encoding. Therefore, the reference set
is emptied before encoding the header fields.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: https
:path: /index.html
:authority: www.example.com
custom-key: custom-value]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Reference set:</preamble>
                <artwork>
<![CDATA[[  1] cache-control: no-cache
[  2] :authority: www.example.com
[  3] :path: /
[  4] :scheme: http
[  5] :method: GET]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[3085 8c8b 8440 8857 1c5c db73 7b2f af89 | 0....@.W.\.s{/..
571c 5cdb 7372 4d9c 57                  | W.\.srM.W]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[30                                      | == Empty reference set ==
                                        |   idx = 0
                                        |   flag = 1
85                                      | == Indexed - Add ==
                                        |   idx = 5
                                        | -> :method: GET
8c                                      | == Indexed - Add ==
                                        |   idx = 12
                                        | -> :scheme: https
8b                                      | == Indexed - Add ==
                                        |   idx = 11
                                        | -> :path: /index.html
84                                      | == Indexed - Add ==
                                        |   idx = 4
                                        | -> :authority: www.example\
                                        |   .com
40                                      | == Literal indexed ==
88                                      |   Literal name (len = 10)
                                        |     Huffman encoded:
571c 5cdb 737b 2faf                     | W.\.s{/.
                                        |     Decoded:
                                        | custom-key
89                                      |   Literal value (len = 12)
                                        |     Huffman encoded:
571c 5cdb 7372 4d9c 57                  | W.\.srM.W
                                        |     Decoded:
                                        | custom-value
                                        | -> custom-key: custom-valu\
                                        |   e]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  54) custom-key: custom-value
[  2] (s =  48) :path: /index.html
[  3] (s =  44) :scheme: https
[  4] (s =  53) cache-control: no-cache
[  5] (s =  57) :authority: www.example.com
[  6] (s =  38) :path: /
[  7] (s =  43) :scheme: http
[  8] (s =  42) :method: GET
      Table size: 379]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:method: GET
:scheme: https
:path: /index.html
:authority: www.example.com
custom-key: custom-value]]></artwork>
            </figure>
        </t>
    </section>

</section>
<section title="Response Examples without Huffman"
    anchor="response.examples.without.huffman">
    <t>
        This section shows several consecutive header sets, corresponding
to HTTP responses, on the same connection. The HTTP/2 setting
SETTINGS_HEADER_TABLE_SIZE is set to the value of 256 octets, causing some
evictions to occur.
    </t>
    <section title="First response">
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:status: 302
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            Reference set: empty.
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[4803 3330 3259 0770 7269 7661 7465 631d | H.302Y.privatec.
4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013
2032 303a 3133 3a32 3120 474d 5471 1768 |  20:13:21 GMTq.h
7474 7073 3a2f 2f77 7777 2e65 7861 6d70 | ttps://www.examp
6c65 2e63 6f6d                          | le.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[48                                      | == Literal indexed ==
                                        |   Indexed name (idx = 8)
                                        |     :status
03                                      |   Literal value (len = 3)
3330 32                                 | 302
                                        | -> :status: 302
59                                      | == Literal indexed ==
                                        |   Indexed name (idx = 25)
                                        |     cache-control
07                                      |   Literal value (len = 7)
7072 6976 6174 65                       | private
                                        | -> cache-control: private
63                                      | == Literal indexed ==
                                        |   Indexed name (idx = 35)
                                        |     date
1d                                      |   Literal value (len = 29)
4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013
2032 303a 3133 3a32 3120 474d 54        |  20:13:21 GMT
                                        | -> date: Mon, 21 Oct 2013 \
                                        |   20:13:21 GMT
71                                      | == Literal indexed ==
                                        |   Indexed name (idx = 49)
                                        |     location
17                                      |   Literal value (len = 23)
6874 7470 733a 2f2f 7777 772e 6578 616d | https://www.exam
706c 652e 636f 6d                       | ple.com
                                        | -> location: https://www.e\
                                        |   xample.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  63) location: https://www.example.com
[  2] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT
[  3] (s =  52) cache-control: private
[  4] (s =  42) :status: 302
      Table size: 222]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:status: 302
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Second response">
        <t>
            The (":status", "302") header field is evicted from the header
table to free space to allow adding the (":status", "200") header
field, copied from the static table into the header table.
The (":status", "302") header field doesn't need to be
removed from the reference set as it is evicted from the header
table.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:status: 200
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Reference set:</preamble>
                <artwork>
<![CDATA[[  1] location: https://www.example.com
[  2] date: Mon, 21 Oct 2013 20:13:21 GMT
[  3] cache-control: private
[  4] :status: 302]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8c                                      | .]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[8c                                      | == Indexed - Add ==
                                        |   idx = 12
                                        | - evict: :status: 302
                                        | -> :status: 200]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  42) :status: 200
[  2] (s =  63) location: https://www.example.com
[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT
[  4] (s =  52) cache-control: private
      Table size: 222]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:status: 200
location: https://www.example.com
date: Mon, 21 Oct 2013 20:13:21 GMT
cache-control: private]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Third response">
        <t>
            Several header fields are evicted from the header table during the
processing of this header set. Before evicting a header belonging to the
reference set, it is emitted, by coding it twice as an Indexed Representation.
The first representation removes the header field from the reference set, the
second one adds it again to the reference set, also emitting it.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:status: 200
cache-control: private
date: Mon, 21 Oct 2013 20:13:22 GMT
location: https://www.example.com
content-encoding: gzip
set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Reference set:</preamble>
                <artwork>
<![CDATA[[  1] :status: 200
[  2] location: https://www.example.com
[  3] date: Mon, 21 Oct 2013 20:13:21 GMT
[  4] cache-control: private]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8484 431d 4d6f 6e2c 2032 3120 4f63 7420 | ..C.Mon, 21 Oct
3230 3133 2032 303a 3133 3a32 3220 474d | 2013 20:13:22 GM
545e 0467 7a69 7084 8483 837b 3866 6f6f | T^.gzip....{8foo
3d41 5344 4a4b 4851 4b42 5a58 4f51 5745 | =ASDJKHQKBZXOQWE
4f50 4955 4158 5157 454f 4955 3b20 6d61 | OPIUAXQWEOIU; ma
782d 6167 653d 3336 3030 3b20 7665 7273 | x-age=3600; vers
696f 6e3d 31                            | ion=1]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[84                                      | == Indexed - Remove ==
                                        |   idx = 4
                                        | -> cache-control: private
84                                      | == Indexed - Add ==
                                        |   idx = 4
                                        | -> cache-control: private
43                                      | == Literal indexed ==
                                        |   Indexed name (idx = 3)
                                        |     date
1d                                      |   Literal value (len = 29)
4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013
2032 303a 3133 3a32 3220 474d 54        |  20:13:22 GMT
                                        | - evict: cache-control: pr\
                                        |   ivate
                                        | -> date: Mon, 21 Oct 2013 \
                                        |   20:13:22 GMT
5e                                      | == Literal indexed ==
                                        |   Indexed name (idx = 30)
                                        |     content-encoding
04                                      |   Literal value (len = 4)
677a 6970                               | gzip
                                        | - evict: date: Mon, 21 Oct\
                                        |    2013 20:13:21 GMT
                                        | -> content-encoding: gzip
84                                      | == Indexed - Remove ==
                                        |   idx = 4
                                        | -> location: https://www.e\
                                        |   xample.com
84                                      | == Indexed - Add ==
                                        |   idx = 4
                                        | -> location: https://www.e\
                                        |   xample.com
83                                      | == Indexed - Remove ==
                                        |   idx = 3
                                        | -> :status: 200
83                                      | == Indexed - Add ==
                                        |   idx = 3
                                        | -> :status: 200
7b                                      | == Literal indexed ==
                                        |   Indexed name (idx = 59)
                                        |     set-cookie
38                                      |   Literal value (len = 56)
666f 6f3d 4153 444a 4b48 514b 425a 584f | foo=ASDJKHQKBZXO
5157 454f 5049 5541 5851 5745 4f49 553b | QWEOPIUAXQWEOIU;
206d 6178 2d61 6765 3d33 3630 303b 2076 |  max-age=3600; v
6572 7369 6f6e 3d31                     | ersion=1
                                        | - evict: location: https:/\
                                        |   /www.example.com
                                        | - evict: :status: 200
                                        | -> set-cookie: foo=ASDJKHQ\
                                        |   KBZXOQWEOPIUAXQWEOIU; ma\
                                        |   x-age=3600; version=1]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  98) set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age\
                 =3600; version=1
[  2] (s =  52) content-encoding: gzip
[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:22 GMT
      Table size: 215]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[cache-control: private
date: Mon, 21 Oct 2013 20:13:22 GMT
content-encoding: gzip
location: https://www.example.com
:status: 200
set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1]]></artwork>
            </figure>
        </t>
    </section>

</section>
<section title="Response Examples with Huffman"
    anchor="response.examples.with.huffman">
    <t>
        This section shows the same examples as the previous section, but
using Huffman encoding for the literal values. The HTTP/2 setting
SETTINGS_HEADER_TABLE_SIZE is set to the value of 256 octets, causing some
evictions to occur. The eviction mechanism uses the length of the decoded
literal values, so the same evictions occurs as in the previous section.
    </t>
    <section title="First response">
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:status: 302
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            Reference set: empty.
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[4882 4017 5985 bf06 724b 9763 93d6 dbb2 | H.@.Y...rK.c....
9884 de2a 7188 0506 2098 5131 09b5 6ba3 | ...*q... .Q1..k.
7191 adce bf19 8e7e 7cf9 bebe 89b6 fb16 | q.......|.......
fa9b 6f                                 | ..o]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[48                                      | == Literal indexed ==
                                        |   Indexed name (idx = 8)
                                        |     :status
82                                      |   Literal value (len = 3)
                                        |     Huffman encoded:
4017                                    | @.
                                        |     Decoded:
                                        | 302
                                        | -> :status: 302
59                                      | == Literal indexed ==
                                        |   Indexed name (idx = 25)
                                        |     cache-control
85                                      |   Literal value (len = 7)
                                        |     Huffman encoded:
bf06 724b 97                            | ..rK.
                                        |     Decoded:
                                        | private
                                        | -> cache-control: private
63                                      | == Literal indexed ==
                                        |   Indexed name (idx = 35)
                                        |     date
93                                      |   Literal value (len = 29)
                                        |     Huffman encoded:
d6db b298 84de 2a71 8805 0620 9851 3109 | ......*q... .Q1.
b56b a3                                 | .k.
                                        |     Decoded:
                                        | Mon, 21 Oct 2013 20:13:21 \
                                        | GMT
                                        | -> date: Mon, 21 Oct 2013 \
                                        |   20:13:21 GMT
71                                      | == Literal indexed ==
                                        |   Indexed name (idx = 49)
                                        |     location
91                                      |   Literal value (len = 23)
                                        |     Huffman encoded:
adce bf19 8e7e 7cf9 bebe 89b6 fb16 fa9b | ......|.........
6f                                      | o
                                        |     Decoded:
                                        | https://www.example.com
                                        | -> location: https://www.e\
                                        |   xample.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  63) location: https://www.example.com
[  2] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT
[  3] (s =  52) cache-control: private
[  4] (s =  42) :status: 302
      Table size: 222]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:status: 302
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Second response">
        <t>
            The (":status", "302") header field is evicted from the header
table to free space to allow adding the (":status", "200") header
field, copied from the static table into the header table.
The (":status", "302") header field doesn't need to be
removed from the reference set as it is evicted from the header
table.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:status: 200
cache-control: private
date: Mon, 21 Oct 2013 20:13:21 GMT
location: https://www.example.com]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Reference set:</preamble>
                <artwork>
<![CDATA[[  1] location: https://www.example.com
[  2] date: Mon, 21 Oct 2013 20:13:21 GMT
[  3] cache-control: private
[  4] :status: 302]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8c                                      | .]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[8c                                      | == Indexed - Add ==
                                        |   idx = 12
                                        | - evict: :status: 302
                                        | -> :status: 200]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  42) :status: 200
[  2] (s =  63) location: https://www.example.com
[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:21 GMT
[  4] (s =  52) cache-control: private
      Table size: 222]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[:status: 200
location: https://www.example.com
date: Mon, 21 Oct 2013 20:13:21 GMT
cache-control: private]]></artwork>
            </figure>
        </t>
    </section>

    <section title="Third response">
        <t>
            Several header fields are evicted from the header table during the
processing of this header set. Before evicting a header belonging to the
reference set, it is emitted, by coding it twice as an Indexed Representation.
The first representation removes the header field from the reference set, the
second one adds it again to the reference set, also emitting it.
        </t>
        <t>
            <figure>
                <preamble>Header set to encode:</preamble>
                <artwork>
<![CDATA[:status: 200
cache-control: private
date: Mon, 21 Oct 2013 20:13:22 GMT
location: https://www.example.com
content-encoding: gzip
set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Reference set:</preamble>
                <artwork>
<![CDATA[[  1] :status: 200
[  2] location: https://www.example.com
[  3] date: Mon, 21 Oct 2013 20:13:21 GMT
[  4] cache-control: private]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Hex dump of encoded data:</preamble>
                <artwork>
<![CDATA[8484 4393 d6db b298 84de 2a71 8805 0620 | ..C.......*q...
9851 3111 b56b a35e 84ab dd97 ff84 8483 | .Q1..k.^........
837b b1e0 d6cf 9f6e 8f9f d3e5 f6fa 76fe | .{.....n......v.
fd3c 7edf 9eff 1f2f 0f3c fe9f 6fcf 7f8f | ......./....o...
879f 61ad 4f4c c9a9 73a2 200e c372 5e18 | ..a.OL..s. ..r^.
b1b7 4e3f                               | ..N?]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoding process:</preamble>
                <artwork>
<![CDATA[84                                      | == Indexed - Remove ==
                                        |   idx = 4
                                        | -> cache-control: private
84                                      | == Indexed - Add ==
                                        |   idx = 4
                                        | -> cache-control: private
43                                      | == Literal indexed ==
                                        |   Indexed name (idx = 3)
                                        |     date
93                                      |   Literal value (len = 29)
                                        |     Huffman encoded:
d6db b298 84de 2a71 8805 0620 9851 3111 | ......*q... .Q1.
b56b a3                                 | .k.
                                        |     Decoded:
                                        | Mon, 21 Oct 2013 20:13:22 \
                                        | GMT
                                        | - evict: cache-control: pr\
                                        |   ivate
                                        | -> date: Mon, 21 Oct 2013 \
                                        |   20:13:22 GMT
5e                                      | == Literal indexed ==
                                        |   Indexed name (idx = 30)
                                        |     content-encoding
84                                      |   Literal value (len = 4)
                                        |     Huffman encoded:
abdd 97ff                               | ....
                                        |     Decoded:
                                        | gzip
                                        | - evict: date: Mon, 21 Oct\
                                        |    2013 20:13:21 GMT
                                        | -> content-encoding: gzip
84                                      | == Indexed - Remove ==
                                        |   idx = 4
                                        | -> location: https://www.e\
                                        |   xample.com
84                                      | == Indexed - Add ==
                                        |   idx = 4
                                        | -> location: https://www.e\
                                        |   xample.com
83                                      | == Indexed - Remove ==
                                        |   idx = 3
                                        | -> :status: 200
83                                      | == Indexed - Add ==
                                        |   idx = 3
                                        | -> :status: 200
7b                                      | == Literal indexed ==
                                        |   Indexed name (idx = 59)
                                        |     set-cookie
b1                                      |   Literal value (len = 56)
                                        |     Huffman encoded:
e0d6 cf9f 6e8f 9fd3 e5f6 fa76 fefd 3c7e | ....n......v....
df9e ff1f 2f0f 3cfe 9f6f cf7f 8f87 9f61 | ..../....o.....a
ad4f 4cc9 a973 a220 0ec3 725e 18b1 b74e | .OL..s. ..r^...N
3f                                      | ?
                                        |     Decoded:
                                        | foo=ASDJKHQKBZXOQWEOPIUAXQ\
                                        | WEOIU; max-age=3600; versi\
                                        | on=1
                                        | - evict: location: https:/\
                                        |   /www.example.com
                                        | - evict: :status: 200
                                        | -> set-cookie: foo=ASDJKHQ\
                                        |   KBZXOQWEOPIUAXQWEOIU; ma\
                                        |   x-age=3600; version=1]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Header Table (after decoding):</preamble>
                <artwork>
<![CDATA[[  1] (s =  98) set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age\
                 =3600; version=1
[  2] (s =  52) content-encoding: gzip
[  3] (s =  65) date: Mon, 21 Oct 2013 20:13:22 GMT
      Table size: 215]]></artwork>
            </figure>
        </t>
        <t>
            <figure>
                <preamble>Decoded header set:</preamble>
                <artwork>
<![CDATA[cache-control: private
date: Mon, 21 Oct 2013 20:13:22 GMT
content-encoding: gzip
location: https://www.example.com
:status: 200
set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1]]></artwork>
            </figure>
        </t>
    </section>

</section>
<!-- example-end -->
        </section>
    </back>
</rfc>
<!--
  vim:et:tw=78:sw=4:
 -->
